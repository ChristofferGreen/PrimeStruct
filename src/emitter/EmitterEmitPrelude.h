  std::ostringstream out;
  out << "// Generated by primec (minimal)\n";
  out << "#include <cerrno>\n";
  out << "#include <cstdint>\n";
  out << "#include <cstdio>\n";
  out << "#include <cmath>\n";
  out << "#include <cstdlib>\n";
  out << "#include <cstring>\n";
  out << "#include <fcntl.h>\n";
  out << "#include <string>\n";
  out << "#include <string_view>\n";
  out << "#include <sys/stat.h>\n";
  out << "#include <unistd.h>\n";
  out << "#include <type_traits>\n";
  out << "#include <unordered_map>\n";
  out << "#include <vector>\n";
  out << "template <typename T, typename Offset>\n";
  out << "static inline T *ps_pointer_add(T *ptr, Offset offset) {\n";
  out << "  if constexpr (std::is_signed_v<Offset>) {\n";
  out << "    return reinterpret_cast<T *>(reinterpret_cast<std::intptr_t>(ptr) + "
         "static_cast<std::intptr_t>(offset));\n";
  out << "  }\n";
  out << "  return reinterpret_cast<T *>(reinterpret_cast<std::uintptr_t>(ptr) + "
         "static_cast<std::uintptr_t>(offset));\n";
  out << "}\n";
  out << "template <typename T, typename Offset>\n";
  out << "static inline T *ps_pointer_add(T &ref, Offset offset) {\n";
  out << "  return ps_pointer_add(&ref, offset);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_abs(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value;\n";
  out << "  }\n";
  out << "  return value < static_cast<T>(0) ? -value : value;\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sign(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value == static_cast<T>(0) ? static_cast<T>(0) : static_cast<T>(1);\n";
  out << "  }\n";
  out << "  if (value < static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(-1);\n";
  out << "  }\n";
  out << "  if (value > static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(1);\n";
  out << "  }\n";
  out << "  return static_cast<T>(0);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_saturate(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value > static_cast<T>(1) ? static_cast<T>(1) : value;\n";
  out << "  }\n";
  out << "  if (value < static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(0);\n";
  out << "  }\n";
  out << "  if (value > static_cast<T>(1)) {\n";
  out << "    return static_cast<T>(1);\n";
  out << "  }\n";
  out << "  return value;\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_min(T left, U right) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  R lhs = static_cast<R>(left);\n";
  out << "  R rhs = static_cast<R>(right);\n";
  out << "  return lhs < rhs ? lhs : rhs;\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_max(T left, U right) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  R lhs = static_cast<R>(left);\n";
  out << "  R rhs = static_cast<R>(right);\n";
  out << "  return lhs > rhs ? lhs : rhs;\n";
  out << "}\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_clamp(T value, U minValue, V maxValue) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  R v = static_cast<R>(value);\n";
  out << "  R minV = static_cast<R>(minValue);\n";
  out << "  R maxV = static_cast<R>(maxValue);\n";
  out << "  if (v < minV) {\n";
  out << "    return minV;\n";
  out << "  }\n";
  out << "  if (v > maxV) {\n";
  out << "    return maxV;\n";
  out << "  }\n";
  out << "  return v;\n";
  out << "}\n";
  out << "static constexpr double ps_const_pi = 3.14159265358979323846;\n";
  out << "static constexpr double ps_const_tau = 6.28318530717958647692;\n";
  out << "static constexpr double ps_const_e = 2.71828182845904523536;\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_lerp(T start, U end, V t) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  R a = static_cast<R>(start);\n";
  out << "  R b = static_cast<R>(end);\n";
  out << "  R tt = static_cast<R>(t);\n";
  out << "  return a + (b - a) * tt;\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_floor(T value) {\n";
  out << "  return static_cast<T>(std::floor(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_ceil(T value) {\n";
  out << "  return static_cast<T>(std::ceil(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_round(T value) {\n";
  out << "  return static_cast<T>(std::round(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_trunc(T value) {\n";
  out << "  return static_cast<T>(std::trunc(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_fract(T value) {\n";
  out << "  long double v = static_cast<long double>(value);\n";
  out << "  return static_cast<T>(v - std::floor(v));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sqrt(T value) {\n";
  out << "  return static_cast<T>(std::sqrt(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cbrt(T value) {\n";
  out << "  return static_cast<T>(std::cbrt(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_pow(T base, U exponent) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  if constexpr (std::is_integral_v<R>) {\n";
  out << "    if constexpr (std::is_signed_v<U>) {\n";
  out << "      if (exponent < 0) {\n";
  out << "        std::fprintf(stderr, \"pow exponent must be non-negative\\n\");\n";
  out << "        std::exit(3);\n";
  out << "      }\n";
  out << "    }\n";
  out << "    using Unsigned = std::make_unsigned_t<R>;\n";
  out << "    Unsigned exp = static_cast<Unsigned>(exponent);\n";
  out << "    R result = static_cast<R>(1);\n";
  out << "    R factor = static_cast<R>(base);\n";
  out << "    while (exp > 0) {\n";
  out << "      if (exp & static_cast<Unsigned>(1)) {\n";
  out << "        result = static_cast<R>(result * factor);\n";
  out << "      }\n";
  out << "      exp >>= static_cast<Unsigned>(1);\n";
  out << "      if (exp == 0) {\n";
  out << "        break;\n";
  out << "      }\n";
  out << "      factor = static_cast<R>(factor * factor);\n";
  out << "    }\n";
  out << "    return result;\n";
  out << "  }\n";
  out << "  return static_cast<R>(std::pow(static_cast<long double>(base), static_cast<long double>(exponent)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_exp(T value) {\n";
  out << "  return static_cast<T>(std::exp(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_exp2(T value) {\n";
  out << "  return static_cast<T>(std::exp2(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log(T value) {\n";
  out << "  return static_cast<T>(std::log(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log2(T value) {\n";
  out << "  return static_cast<T>(std::log2(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log10(T value) {\n";
  out << "  return static_cast<T>(std::log10(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sin(T value) {\n";
  out << "  return static_cast<T>(std::sin(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cos(T value) {\n";
  out << "  return static_cast<T>(std::cos(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_tan(T value) {\n";
  out << "  return static_cast<T>(std::tan(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_asin(T value) {\n";
  out << "  return static_cast<T>(std::asin(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_acos(T value) {\n";
  out << "  return static_cast<T>(std::acos(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_atan(T value) {\n";
  out << "  return static_cast<T>(std::atan(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_atan2(T y, U x) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::atan2(static_cast<long double>(y), static_cast<long double>(x)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_radians(T value) {\n";
  out << "  return static_cast<T>(static_cast<long double>(value) * (ps_const_pi / 180.0));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_degrees(T value) {\n";
  out << "  return static_cast<T>(static_cast<long double>(value) * (180.0 / ps_const_pi));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sinh(T value) {\n";
  out << "  return static_cast<T>(std::sinh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cosh(T value) {\n";
  out << "  return static_cast<T>(std::cosh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_tanh(T value) {\n";
  out << "  return static_cast<T>(std::tanh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_asinh(T value) {\n";
  out << "  return static_cast<T>(std::asinh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_acosh(T value) {\n";
  out << "  return static_cast<T>(std::acosh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_atanh(T value) {\n";
  out << "  return static_cast<T>(std::atanh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_fma(T a, U b, V c) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  return static_cast<R>(std::fma(static_cast<long double>(a), static_cast<long double>(b), static_cast<long double>(c)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_hypot(T a, U b) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::hypot(static_cast<long double>(a), static_cast<long double>(b)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_copysign(T mag, U sign) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::copysign(static_cast<long double>(mag), static_cast<long double>(sign)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_nan(T value) {\n";
  out << "  return std::isnan(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_inf(T value) {\n";
  out << "  return std::isinf(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_finite(T value) {\n";
  out << "  return std::isfinite(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline int ps_array_count(const std::vector<T> &value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Key, typename Value>\n";
  out << "static inline int ps_map_count(const std::unordered_map<Key, Value> &value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Key, typename Value, typename K>\n";
  out << "static inline const Value &ps_map_at(const std::unordered_map<Key, Value> &value, const K &key) {\n";
  out << "  auto it = value.find(key);\n";
  out << "  if (it == value.end()) {\n";
  out << "    std::fprintf(stderr, \"map key not found\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return it->second;\n";
  out << "}\n";
  out << "template <typename Key, typename Value, typename K>\n";
  out << "static inline const Value &ps_map_at_unsafe(const std::unordered_map<Key, Value> &value, const K &key) {\n";
  out << "  return value.find(key)->second;\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline const T &ps_array_at(const std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"array index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return value[static_cast<size_t>(i)];\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline const T &ps_array_at_unsafe(const std::vector<T> &value, Index index) {\n";
  out << "  return value[static_cast<size_t>(index)];\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline int ps_vector_capacity(const std::vector<T> &value) {\n";
  out << "  return static_cast<int>(value.capacity());\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_reserve(std::vector<T> &value, Index capacity) {\n";
  out << "  int64_t cap = static_cast<int64_t>(capacity);\n";
  out << "  if (cap < 0) {\n";
  out << "    std::fprintf(stderr, \"vector reserve expects non-negative capacity\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.reserve(static_cast<size_t>(cap));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline void ps_vector_pop(std::vector<T> &value) {\n";
  out << "  if (value.empty()) {\n";
  out << "    std::fprintf(stderr, \"vector pop on empty\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.pop_back();\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_remove_at(std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"vector index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.erase(value.begin() + static_cast<size_t>(i));\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_remove_swap(std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"vector index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  size_t idx = static_cast<size_t>(i);\n";
  out << "  if (idx + 1 < value.size()) {\n";
  out << "    value[idx] = std::move(value.back());\n";
  out << "  }\n";
  out << "  value.pop_back();\n";
  out << "}\n";
  out << "static inline int ps_string_count(std::string_view value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Index>\n";
  out << "static inline int ps_string_at(std::string_view value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"string index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return static_cast<unsigned char>(value[static_cast<size_t>(i)]);\n";
  out << "}\n";
  out << "template <typename Index>\n";
  out << "static inline int ps_string_at_unsafe(std::string_view value, Index index) {\n";
  out << "  return static_cast<unsigned char>(value[static_cast<size_t>(index)]);\n";
  out << "}\n";
  out << "static inline void ps_write(FILE *stream, const char *data, size_t len, bool newline) {\n";
  out << "  if (len > 0) {\n";
  out << "    std::fwrite(data, 1, len, stream);\n";
  out << "  }\n";
  out << "  if (newline) {\n";
  out << "    std::fputc('\\n', stream);\n";
  out << "  }\n";
  out << "}\n";
  out << "static inline void ps_print_value(FILE *stream, const char *text, bool newline) {\n";
  out << "  if (!text) {\n";
  out << "    if (newline) {\n";
  out << "      std::fputc('\\n', stream);\n";
  out << "    }\n";
  out << "    return;\n";
  out << "  }\n";
  out << "  ps_write(stream, text, std::strlen(text), newline);\n";
  out << "}\n";
  out << "static inline void ps_print_value(FILE *stream, std::string_view text, bool newline) {\n";
  out << "  ps_write(stream, text.data(), text.size(), newline);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline void ps_print_value(FILE *stream, T value, bool newline) {\n";
  out << "  std::string text = std::to_string(value);\n";
  out << "  ps_write(stream, text.c_str(), text.size(), newline);\n";
  out << "}\n";
  out << "struct ps_result_unwind {\n";
  out << "  uint32_t error = 0;\n";
  out << "};\n";
  out << "struct ps_file_handle {\n";
  out << "  mutable int fd = -1;\n";
  out << "  ps_file_handle() = default;\n";
  out << "  explicit ps_file_handle(int fdIn) : fd(fdIn) {}\n";
  out << "  ps_file_handle(const ps_file_handle &) = delete;\n";
  out << "  ps_file_handle &operator=(const ps_file_handle &) = delete;\n";
  out << "  ps_file_handle(ps_file_handle &&other) noexcept : fd(other.fd) { other.fd = -1; }\n";
  out << "  ps_file_handle &operator=(ps_file_handle &&other) noexcept {\n";
  out << "    if (this != &other) {\n";
  out << "      if (fd >= 0) {\n";
  out << "        ::close(fd);\n";
  out << "      }\n";
  out << "      fd = other.fd;\n";
  out << "      other.fd = -1;\n";
  out << "    }\n";
  out << "    return *this;\n";
  out << "  }\n";
  out << "  ~ps_file_handle() {\n";
  out << "    if (fd >= 0) {\n";
  out << "      ::close(fd);\n";
  out << "    }\n";
  out << "  }\n";
  out << "};\n";
  out << "static inline uint32_t ps_errno_value() {\n";
  out << "  return errno == 0 ? 1u : static_cast<uint32_t>(errno);\n";
  out << "}\n";
  out << "static inline uint64_t ps_result_pack(uint32_t err, uint32_t value) {\n";
  out << "  return (static_cast<uint64_t>(err) << 32) | static_cast<uint64_t>(value);\n";
  out << "}\n";
  out << "static inline uint32_t ps_result_error(uint64_t result) {\n";
  out << "  return static_cast<uint32_t>(result >> 32);\n";
  out << "}\n";
  out << "static inline uint32_t ps_result_value(uint64_t result) {\n";
  out << "  return static_cast<uint32_t>(result & 0xffffffffu);\n";
  out << "}\n";
  out << "template <typename Handler>\n";
  out << "static inline uint32_t ps_try_status(uint32_t result, Handler &&handler) {\n";
  out << "  if (result != 0) {\n";
  out << "    handler(result);\n";
  out << "    throw ps_result_unwind{result};\n";
  out << "  }\n";
  out << "  return 0;\n";
  out << "}\n";
  out << "template <typename T, typename Handler>\n";
  out << "static inline T ps_try_value(uint64_t result, Handler &&handler) {\n";
  out << "  uint32_t err = ps_result_error(result);\n";
  out << "  if (err != 0) {\n";
  out << "    handler(err);\n";
  out << "    throw ps_result_unwind{err};\n";
  out << "  }\n";
  out << "  return static_cast<T>(ps_result_value(result));\n";
  out << "}\n";
  out << "template <typename Handler>\n";
  out << "static inline ps_file_handle ps_try_file(uint64_t result, Handler &&handler) {\n";
  out << "  uint32_t err = ps_result_error(result);\n";
  out << "  if (err != 0) {\n";
  out << "    handler(err);\n";
  out << "    throw ps_result_unwind{err};\n";
  out << "  }\n";
  out << "  return ps_file_handle(static_cast<int>(ps_result_value(result)));\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_all(int fd, const void *data, size_t size) {\n";
  out << "  const char *cursor = static_cast<const char *>(data);\n";
  out << "  size_t remaining = size;\n";
  out << "  while (remaining > 0) {\n";
  out << "    ssize_t wrote = ::write(fd, cursor, remaining);\n";
  out << "    if (wrote < 0) {\n";
  out << "      return ps_errno_value();\n";
  out << "    }\n";
  out << "    if (wrote == 0) {\n";
  out << "      return EIO;\n";
  out << "    }\n";
  out << "    remaining -= static_cast<size_t>(wrote);\n";
  out << "    cursor += wrote;\n";
  out << "  }\n";
  out << "  return 0;\n";
  out << "}\n";
  out << "static inline uint64_t ps_file_open_read(std::string_view path) {\n";
  out << "  std::string pathText(path);\n";
  out << "  int fd = ::open(pathText.c_str(), O_RDONLY);\n";
  out << "  if (fd < 0) {\n";
  out << "    return ps_result_pack(ps_errno_value(), 0u);\n";
  out << "  }\n";
  out << "  return ps_result_pack(0u, static_cast<uint32_t>(fd));\n";
  out << "}\n";
  out << "static inline uint64_t ps_file_open_write(std::string_view path) {\n";
  out << "  std::string pathText(path);\n";
  out << "  int fd = ::open(pathText.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n";
  out << "  if (fd < 0) {\n";
  out << "    return ps_result_pack(ps_errno_value(), 0u);\n";
  out << "  }\n";
  out << "  return ps_result_pack(0u, static_cast<uint32_t>(fd));\n";
  out << "}\n";
  out << "static inline uint64_t ps_file_open_append(std::string_view path) {\n";
  out << "  std::string pathText(path);\n";
  out << "  int fd = ::open(pathText.c_str(), O_WRONLY | O_CREAT | O_APPEND, 0644);\n";
  out << "  if (fd < 0) {\n";
  out << "    return ps_result_pack(ps_errno_value(), 0u);\n";
  out << "  }\n";
  out << "  return ps_result_pack(0u, static_cast<uint32_t>(fd));\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_value(const ps_file_handle &file, std::string_view text) {\n";
  out << "  if (text.empty()) {\n";
  out << "    return 0;\n";
  out << "  }\n";
  out << "  return ps_file_write_all(file.fd, text.data(), text.size());\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_value(const ps_file_handle &file, const char *text) {\n";
  out << "  if (!text) {\n";
  out << "    return 0;\n";
  out << "  }\n";
  out << "  return ps_file_write_all(file.fd, text, std::strlen(text));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline uint32_t ps_file_write_value(const ps_file_handle &file, T value) {\n";
  out << "  std::string text = std::to_string(value);\n";
  out << "  return ps_file_write_all(file.fd, text.data(), text.size());\n";
  out << "}\n";
  out << "template <typename... Args>\n";
  out << "static inline uint32_t ps_file_write(const ps_file_handle &file, const Args &... args) {\n";
  out << "  uint32_t err = 0;\n";
  out << "  ((err == 0 ? (err = ps_file_write_value(file, args)) : err), ...);\n";
  out << "  return err;\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write(const ps_file_handle &file) {\n";
  out << "  (void)file;\n";
  out << "  return 0u;\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_newline(const ps_file_handle &file) {\n";
  out << "  const char newline = '\\n';\n";
  out << "  return ps_file_write_all(file.fd, &newline, 1);\n";
  out << "}\n";
  out << "template <typename... Args>\n";
  out << "static inline uint32_t ps_file_write_line(const ps_file_handle &file, const Args &... args) {\n";
  out << "  uint32_t err = ps_file_write(file, args...);\n";
  out << "  if (err != 0) {\n";
  out << "    return err;\n";
  out << "  }\n";
  out << "  return ps_file_write_newline(file);\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_line(const ps_file_handle &file) {\n";
  out << "  return ps_file_write_newline(file);\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_write_byte(const ps_file_handle &file, uint64_t value) {\n";
  out << "  uint8_t byte = static_cast<uint8_t>(value & 0xffu);\n";
  out << "  return ps_file_write_all(file.fd, &byte, 1);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline uint32_t ps_file_write_bytes(const ps_file_handle &file, const std::vector<T> &bytes) {\n";
  out << "  uint32_t err = 0;\n";
  out << "  for (const auto &value : bytes) {\n";
  out << "    if (err != 0) {\n";
  out << "      break;\n";
  out << "    }\n";
  out << "    uint8_t byte = static_cast<uint8_t>(value);\n";
  out << "    err = ps_file_write_all(file.fd, &byte, 1);\n";
  out << "  }\n";
  out << "  return err;\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_flush(const ps_file_handle &file) {\n";
  out << "  int rc = ::fsync(file.fd);\n";
  out << "  return (rc < 0) ? ps_errno_value() : 0u;\n";
  out << "}\n";
  out << "static inline uint32_t ps_file_close(const ps_file_handle &file) {\n";
  out << "  if (file.fd < 0) {\n";
  out << "    return 0u;\n";
  out << "  }\n";
  out << "  int fd = file.fd;\n";
  out << "  file.fd = -1;\n";
  out << "  int rc = ::close(fd);\n";
  out << "  return (rc < 0) ? ps_errno_value() : 0u;\n";
  out << "}\n";
  out << "static inline std::string_view ps_file_error_why(uint32_t err) {\n";
  out << "  const char *text = std::strerror(static_cast<int>(err));\n";
  out << "  return text ? std::string_view(text) : std::string_view();\n";
  out << "}\n";
