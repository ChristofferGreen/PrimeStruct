  std::ostringstream out;
  out << "// Generated by primec (minimal)\n";
  out << "#include <cstdint>\n";
  out << "#include <cstdio>\n";
  out << "#include <cmath>\n";
  out << "#include <cstdlib>\n";
  out << "#include <cstring>\n";
  out << "#include <string>\n";
  out << "#include <string_view>\n";
  out << "#include <type_traits>\n";
  out << "#include <unordered_map>\n";
  out << "#include <vector>\n";
  out << "template <typename T, typename Offset>\n";
  out << "static inline T *ps_pointer_add(T *ptr, Offset offset) {\n";
  out << "  if constexpr (std::is_signed_v<Offset>) {\n";
  out << "    return reinterpret_cast<T *>(reinterpret_cast<std::intptr_t>(ptr) + "
         "static_cast<std::intptr_t>(offset));\n";
  out << "  }\n";
  out << "  return reinterpret_cast<T *>(reinterpret_cast<std::uintptr_t>(ptr) + "
         "static_cast<std::uintptr_t>(offset));\n";
  out << "}\n";
  out << "template <typename T, typename Offset>\n";
  out << "static inline T *ps_pointer_add(T &ref, Offset offset) {\n";
  out << "  return ps_pointer_add(&ref, offset);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_abs(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value;\n";
  out << "  }\n";
  out << "  return value < static_cast<T>(0) ? -value : value;\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sign(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value == static_cast<T>(0) ? static_cast<T>(0) : static_cast<T>(1);\n";
  out << "  }\n";
  out << "  if (value < static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(-1);\n";
  out << "  }\n";
  out << "  if (value > static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(1);\n";
  out << "  }\n";
  out << "  return static_cast<T>(0);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_saturate(T value) {\n";
  out << "  if constexpr (std::is_unsigned_v<T>) {\n";
  out << "    return value > static_cast<T>(1) ? static_cast<T>(1) : value;\n";
  out << "  }\n";
  out << "  if (value < static_cast<T>(0)) {\n";
  out << "    return static_cast<T>(0);\n";
  out << "  }\n";
  out << "  if (value > static_cast<T>(1)) {\n";
  out << "    return static_cast<T>(1);\n";
  out << "  }\n";
  out << "  return value;\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_min(T left, U right) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  R lhs = static_cast<R>(left);\n";
  out << "  R rhs = static_cast<R>(right);\n";
  out << "  return lhs < rhs ? lhs : rhs;\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_max(T left, U right) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  R lhs = static_cast<R>(left);\n";
  out << "  R rhs = static_cast<R>(right);\n";
  out << "  return lhs > rhs ? lhs : rhs;\n";
  out << "}\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_clamp(T value, U minValue, V maxValue) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  R v = static_cast<R>(value);\n";
  out << "  R minV = static_cast<R>(minValue);\n";
  out << "  R maxV = static_cast<R>(maxValue);\n";
  out << "  if (v < minV) {\n";
  out << "    return minV;\n";
  out << "  }\n";
  out << "  if (v > maxV) {\n";
  out << "    return maxV;\n";
  out << "  }\n";
  out << "  return v;\n";
  out << "}\n";
  out << "static constexpr double ps_const_pi = 3.14159265358979323846;\n";
  out << "static constexpr double ps_const_tau = 6.28318530717958647692;\n";
  out << "static constexpr double ps_const_e = 2.71828182845904523536;\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_lerp(T start, U end, V t) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  R a = static_cast<R>(start);\n";
  out << "  R b = static_cast<R>(end);\n";
  out << "  R tt = static_cast<R>(t);\n";
  out << "  return a + (b - a) * tt;\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_floor(T value) {\n";
  out << "  return static_cast<T>(std::floor(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_ceil(T value) {\n";
  out << "  return static_cast<T>(std::ceil(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_round(T value) {\n";
  out << "  return static_cast<T>(std::round(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_trunc(T value) {\n";
  out << "  return static_cast<T>(std::trunc(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_fract(T value) {\n";
  out << "  long double v = static_cast<long double>(value);\n";
  out << "  return static_cast<T>(v - std::floor(v));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sqrt(T value) {\n";
  out << "  return static_cast<T>(std::sqrt(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cbrt(T value) {\n";
  out << "  return static_cast<T>(std::cbrt(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_pow(T base, U exponent) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  if constexpr (std::is_integral_v<R>) {\n";
  out << "    if constexpr (std::is_signed_v<U>) {\n";
  out << "      if (exponent < 0) {\n";
  out << "        std::fprintf(stderr, \"pow exponent must be non-negative\\n\");\n";
  out << "        std::exit(3);\n";
  out << "      }\n";
  out << "    }\n";
  out << "    using Unsigned = std::make_unsigned_t<R>;\n";
  out << "    Unsigned exp = static_cast<Unsigned>(exponent);\n";
  out << "    R result = static_cast<R>(1);\n";
  out << "    R factor = static_cast<R>(base);\n";
  out << "    while (exp > 0) {\n";
  out << "      if (exp & static_cast<Unsigned>(1)) {\n";
  out << "        result = static_cast<R>(result * factor);\n";
  out << "      }\n";
  out << "      exp >>= static_cast<Unsigned>(1);\n";
  out << "      if (exp == 0) {\n";
  out << "        break;\n";
  out << "      }\n";
  out << "      factor = static_cast<R>(factor * factor);\n";
  out << "    }\n";
  out << "    return result;\n";
  out << "  }\n";
  out << "  return static_cast<R>(std::pow(static_cast<long double>(base), static_cast<long double>(exponent)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_exp(T value) {\n";
  out << "  return static_cast<T>(std::exp(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_exp2(T value) {\n";
  out << "  return static_cast<T>(std::exp2(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log(T value) {\n";
  out << "  return static_cast<T>(std::log(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log2(T value) {\n";
  out << "  return static_cast<T>(std::log2(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_log10(T value) {\n";
  out << "  return static_cast<T>(std::log10(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sin(T value) {\n";
  out << "  return static_cast<T>(std::sin(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cos(T value) {\n";
  out << "  return static_cast<T>(std::cos(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_tan(T value) {\n";
  out << "  return static_cast<T>(std::tan(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_asin(T value) {\n";
  out << "  return static_cast<T>(std::asin(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_acos(T value) {\n";
  out << "  return static_cast<T>(std::acos(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_atan(T value) {\n";
  out << "  return static_cast<T>(std::atan(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_atan2(T y, U x) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::atan2(static_cast<long double>(y), static_cast<long double>(x)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_radians(T value) {\n";
  out << "  return static_cast<T>(static_cast<long double>(value) * (ps_const_pi / 180.0));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_degrees(T value) {\n";
  out << "  return static_cast<T>(static_cast<long double>(value) * (180.0 / ps_const_pi));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_sinh(T value) {\n";
  out << "  return static_cast<T>(std::sinh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_cosh(T value) {\n";
  out << "  return static_cast<T>(std::cosh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_tanh(T value) {\n";
  out << "  return static_cast<T>(std::tanh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_asinh(T value) {\n";
  out << "  return static_cast<T>(std::asinh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_acosh(T value) {\n";
  out << "  return static_cast<T>(std::acosh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline T ps_builtin_atanh(T value) {\n";
  out << "  return static_cast<T>(std::atanh(static_cast<long double>(value)));\n";
  out << "}\n";
  out << "template <typename T, typename U, typename V>\n";
  out << "static inline std::common_type_t<T, U, V> ps_builtin_fma(T a, U b, V c) {\n";
  out << "  using R = std::common_type_t<T, U, V>;\n";
  out << "  return static_cast<R>(std::fma(static_cast<long double>(a), static_cast<long double>(b), static_cast<long double>(c)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_hypot(T a, U b) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::hypot(static_cast<long double>(a), static_cast<long double>(b)));\n";
  out << "}\n";
  out << "template <typename T, typename U>\n";
  out << "static inline std::common_type_t<T, U> ps_builtin_copysign(T mag, U sign) {\n";
  out << "  using R = std::common_type_t<T, U>;\n";
  out << "  return static_cast<R>(std::copysign(static_cast<long double>(mag), static_cast<long double>(sign)));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_nan(T value) {\n";
  out << "  return std::isnan(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_inf(T value) {\n";
  out << "  return std::isinf(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline bool ps_builtin_is_finite(T value) {\n";
  out << "  return std::isfinite(static_cast<long double>(value));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline int ps_array_count(const std::vector<T> &value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Key, typename Value>\n";
  out << "static inline int ps_map_count(const std::unordered_map<Key, Value> &value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Key, typename Value, typename K>\n";
  out << "static inline const Value &ps_map_at(const std::unordered_map<Key, Value> &value, const K &key) {\n";
  out << "  auto it = value.find(key);\n";
  out << "  if (it == value.end()) {\n";
  out << "    std::fprintf(stderr, \"map key not found\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return it->second;\n";
  out << "}\n";
  out << "template <typename Key, typename Value, typename K>\n";
  out << "static inline const Value &ps_map_at_unsafe(const std::unordered_map<Key, Value> &value, const K &key) {\n";
  out << "  return value.find(key)->second;\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline const T &ps_array_at(const std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"array index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return value[static_cast<size_t>(i)];\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline const T &ps_array_at_unsafe(const std::vector<T> &value, Index index) {\n";
  out << "  return value[static_cast<size_t>(index)];\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline int ps_vector_capacity(const std::vector<T> &value) {\n";
  out << "  return static_cast<int>(value.capacity());\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_reserve(std::vector<T> &value, Index capacity) {\n";
  out << "  int64_t cap = static_cast<int64_t>(capacity);\n";
  out << "  if (cap < 0) {\n";
  out << "    std::fprintf(stderr, \"vector reserve expects non-negative capacity\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.reserve(static_cast<size_t>(cap));\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline void ps_vector_pop(std::vector<T> &value) {\n";
  out << "  if (value.empty()) {\n";
  out << "    std::fprintf(stderr, \"vector pop on empty\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.pop_back();\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_remove_at(std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"vector index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  value.erase(value.begin() + static_cast<size_t>(i));\n";
  out << "}\n";
  out << "template <typename T, typename Index>\n";
  out << "static inline void ps_vector_remove_swap(std::vector<T> &value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"vector index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  size_t idx = static_cast<size_t>(i);\n";
  out << "  if (idx + 1 < value.size()) {\n";
  out << "    value[idx] = std::move(value.back());\n";
  out << "  }\n";
  out << "  value.pop_back();\n";
  out << "}\n";
  out << "static inline int ps_string_count(std::string_view value) {\n";
  out << "  return static_cast<int>(value.size());\n";
  out << "}\n";
  out << "template <typename Index>\n";
  out << "static inline int ps_string_at(std::string_view value, Index index) {\n";
  out << "  int64_t i = static_cast<int64_t>(index);\n";
  out << "  if (i < 0 || static_cast<size_t>(i) >= value.size()) {\n";
  out << "    std::fprintf(stderr, \"string index out of bounds\\n\");\n";
  out << "    std::exit(3);\n";
  out << "  }\n";
  out << "  return static_cast<unsigned char>(value[static_cast<size_t>(i)]);\n";
  out << "}\n";
  out << "template <typename Index>\n";
  out << "static inline int ps_string_at_unsafe(std::string_view value, Index index) {\n";
  out << "  return static_cast<unsigned char>(value[static_cast<size_t>(index)]);\n";
  out << "}\n";
  out << "static inline void ps_write(FILE *stream, const char *data, size_t len, bool newline) {\n";
  out << "  if (len > 0) {\n";
  out << "    std::fwrite(data, 1, len, stream);\n";
  out << "  }\n";
  out << "  if (newline) {\n";
  out << "    std::fputc('\\n', stream);\n";
  out << "  }\n";
  out << "}\n";
  out << "static inline void ps_print_value(FILE *stream, const char *text, bool newline) {\n";
  out << "  if (!text) {\n";
  out << "    if (newline) {\n";
  out << "      std::fputc('\\n', stream);\n";
  out << "    }\n";
  out << "    return;\n";
  out << "  }\n";
  out << "  ps_write(stream, text, std::strlen(text), newline);\n";
  out << "}\n";
  out << "static inline void ps_print_value(FILE *stream, std::string_view text, bool newline) {\n";
  out << "  ps_write(stream, text.data(), text.size(), newline);\n";
  out << "}\n";
  out << "template <typename T>\n";
  out << "static inline void ps_print_value(FILE *stream, T value, bool newline) {\n";
  out << "  std::string text = std::to_string(value);\n";
  out << "  ps_write(stream, text.c_str(), text.size(), newline);\n";
  out << "}\n";
