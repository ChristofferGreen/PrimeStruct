#include "primec/Emitter.h"

#include <functional>
#include <sstream>
#include <unordered_map>

namespace primec {
namespace {
enum class ReturnKind { Int, Void };

struct BindingInfo {
  std::string typeName;
  bool isMutable = false;
};

ReturnKind getReturnKind(const Definition &def) {
  for (const auto &transform : def.transforms) {
    if (transform.name != "return" || !transform.templateArg) {
      continue;
    }
    if (*transform.templateArg == "void") {
      return ReturnKind::Void;
    }
    if (*transform.templateArg == "int") {
      return ReturnKind::Int;
    }
  }
  return ReturnKind::Int;
}

BindingInfo getBindingInfo(const Expr &expr) {
  BindingInfo info;
  for (const auto &transform : expr.transforms) {
    if (transform.name == "mut" && !transform.templateArg) {
      info.isMutable = true;
      continue;
    }
    if (!transform.templateArg) {
      info.typeName = transform.name;
    }
  }
  if (info.typeName.empty()) {
    info.typeName = "int";
  }
  return info;
}

std::string bindingTypeToCpp(const std::string &typeName) {
  if (typeName == "i32" || typeName == "int") {
    return "int";
  }
  return "int";
}

bool getBuiltinOperator(const Expr &expr, char &out) {
  if (expr.name.empty()) {
    return false;
  }
  std::string name = expr.name;
  if (!name.empty() && name[0] == '/') {
    name.erase(0, 1);
  }
  if (name.find('/') != std::string::npos) {
    return false;
  }
  if (name == "plus") {
    out = '+';
    return true;
  }
  if (name == "minus") {
    out = '-';
    return true;
  }
  if (name == "multiply") {
    out = '*';
    return true;
  }
  if (name == "divide") {
    out = '/';
    return true;
  }
  return false;
}

std::string resolveExprPath(const Expr &expr) {
  if (!expr.name.empty() && expr.name[0] == '/') {
    return expr.name;
  }
  if (!expr.namespacePrefix.empty()) {
    return expr.namespacePrefix + "/" + expr.name;
  }
  return "/" + expr.name;
}

bool isBuiltinAssign(const Expr &expr, const std::unordered_map<std::string, std::string> &nameMap) {
  if (expr.kind != Expr::Kind::Call || expr.name.empty()) {
    return false;
  }
  std::string full = resolveExprPath(expr);
  if (nameMap.count(full) > 0) {
    return false;
  }
  std::string name = expr.name;
  if (!name.empty() && name[0] == '/') {
    name.erase(0, 1);
  }
  if (name.find('/') != std::string::npos) {
    return false;
  }
  return name == "assign";
}

bool isSimpleCallName(const Expr &expr, const char *nameToMatch) {
  if (expr.kind != Expr::Kind::Call || expr.name.empty()) {
    return false;
  }
  std::string name = expr.name;
  if (!name.empty() && name[0] == '/') {
    name.erase(0, 1);
  }
  if (name.find('/') != std::string::npos) {
    return false;
  }
  return name == nameToMatch;
}

bool isBuiltinIf(const Expr &expr, const std::unordered_map<std::string, std::string> &nameMap) {
  std::string full = resolveExprPath(expr);
  if (nameMap.count(full) > 0) {
    return false;
  }
  return isSimpleCallName(expr, "if");
}

bool isThenCall(const Expr &expr) {
  return isSimpleCallName(expr, "then");
}

bool isElseCall(const Expr &expr) {
  return isSimpleCallName(expr, "else");
}
} // namespace

std::string Emitter::toCppName(const std::string &fullPath) const {
  std::string name = "ps";
  for (char c : fullPath) {
    if (c == '/') {
      name += "_";
    } else {
      name += c;
    }
  }
  return name;
}

std::string Emitter::emitExpr(const Expr &expr,
                              const std::unordered_map<std::string, std::string> &nameMap) const {
  if (expr.kind == Expr::Kind::Literal) {
    return std::to_string(expr.literalValue);
  }
  if (expr.kind == Expr::Kind::Name) {
    return expr.name;
  }
  std::string full = resolveExprPath(expr);
  auto it = nameMap.find(full);
  if (it == nameMap.end()) {
    char op = '\0';
    if (getBuiltinOperator(expr, op) && expr.args.size() == 2) {
      std::ostringstream out;
      out << "(" << emitExpr(expr.args[0], nameMap) << " " << op << " "
          << emitExpr(expr.args[1], nameMap) << ")";
      return out.str();
    }
    if (isBuiltinAssign(expr, nameMap) && expr.args.size() == 2) {
      std::ostringstream out;
      out << "(" << emitExpr(expr.args[0], nameMap) << " = " << emitExpr(expr.args[1], nameMap) << ")";
      return out.str();
    }
    return "0";
  }
  std::ostringstream out;
  out << it->second << "(";
  for (size_t i = 0; i < expr.args.size(); ++i) {
    if (i > 0) {
      out << ", ";
    }
    out << emitExpr(expr.args[i], nameMap);
  }
  out << ")";
  return out.str();
}

std::string Emitter::emitCpp(const Program &program, const std::string &entryPath) const {
  std::unordered_map<std::string, std::string> nameMap;
  for (const auto &def : program.definitions) {
    nameMap[def.fullPath] = toCppName(def.fullPath);
  }

  std::ostringstream out;
  out << "// Generated by primec (minimal)\n";
  for (const auto &def : program.definitions) {
    ReturnKind returnKind = getReturnKind(def);
    out << "static " << (returnKind == ReturnKind::Void ? "void" : "int") << " " << nameMap[def.fullPath]
        << "(";
    for (size_t i = 0; i < def.parameters.size(); ++i) {
      if (i > 0) {
        out << ", ";
      }
      out << "int " << def.parameters[i];
    }
    out << ") {\n";
    std::function<void(const Expr &, int)> emitStatement;
    emitStatement = [&](const Expr &stmt, int indent) {
      std::string pad(static_cast<size_t>(indent) * 2, ' ');
      if (stmt.isBinding) {
        BindingInfo binding = getBindingInfo(stmt);
        std::string type = bindingTypeToCpp(binding.typeName);
        out << pad << (binding.isMutable ? "" : "const ") << type << " " << stmt.name;
        if (!stmt.args.empty()) {
          out << " = " << emitExpr(stmt.args.front(), nameMap);
        }
        out << ";\n";
        return;
      }
      if (isBuiltinIf(stmt, nameMap) && stmt.args.size() == 3) {
        const Expr &cond = stmt.args[0];
        const Expr &thenBlock = stmt.args[1];
        const Expr &elseBlock = stmt.args[2];
        out << pad << "if (" << emitExpr(cond, nameMap) << ") {\n";
        if (isThenCall(thenBlock)) {
          for (const auto &bodyStmt : thenBlock.bodyArguments) {
            emitStatement(bodyStmt, indent + 1);
          }
        }
        out << pad << "} else {\n";
        if (isElseCall(elseBlock)) {
          for (const auto &bodyStmt : elseBlock.bodyArguments) {
            emitStatement(bodyStmt, indent + 1);
          }
        }
        out << pad << "}\n";
        return;
      }
      if (stmt.kind == Expr::Kind::Call && isBuiltinAssign(stmt, nameMap) && stmt.args.size() == 2 &&
          stmt.args.front().kind == Expr::Kind::Name) {
        out << pad << stmt.args.front().name << " = " << emitExpr(stmt.args[1], nameMap) << ";\n";
        return;
      }
      out << pad << emitExpr(stmt, nameMap) << ";\n";
    };
    for (const auto &stmt : def.statements) {
      emitStatement(stmt, 1);
    }
    if (returnKind == ReturnKind::Void) {
      if (def.returnExpr) {
        out << "  " << emitExpr(*def.returnExpr, nameMap) << ";\n";
      }
      out << "  return;\n";
    } else {
      out << "  return " << emitExpr(*def.returnExpr, nameMap) << ";\n";
    }
    out << "}\n";
  }
  ReturnKind entryReturn = ReturnKind::Int;
  for (const auto &def : program.definitions) {
    if (def.fullPath == entryPath) {
      entryReturn = getReturnKind(def);
      break;
    }
  }
  if (entryReturn == ReturnKind::Void) {
    out << "int main() { " << nameMap.at(entryPath) << "(); return 0; }\n";
  } else {
    out << "int main() { return " << nameMap.at(entryPath) << "(); }\n";
  }
  return out.str();
}

} // namespace primec
