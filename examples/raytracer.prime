import /math/*

[array<f32>]
vec([f32] x, [f32] y, [f32] z) {
  return(array<f32>(x, y, z))
}

[array<f32>]
add([array<f32>] a, [array<f32>] b) {
  return(array<f32>(a[0] + b[0], a[1] + b[1], a[2] + b[2]))
}

[array<f32>]
sub([array<f32>] a, [array<f32>] b) {
  return(array<f32>(a[0] - b[0], a[1] - b[1], a[2] - b[2]))
}

[array<f32>]
mul_scalar([array<f32>] v, [f32] s) {
  return(array<f32>(v[0] * s, v[1] * s, v[2] * s))
}

[f32]
dot([array<f32>] a, [array<f32>] b) {
  return(a[0] * b[0] + a[1] * b[1] + a[2] * b[2])
}

[array<f32>]
normalize([array<f32>] v) {
  [f32] len{sqrt(dot(v, v))}
  if(len <= 0.0) {
    return(v)
  } else {
    [f32] inv{1.0 / len}
    return(mul_scalar(v, inv))
  }
}

[array<f32>]
mix([array<f32>] a, [array<f32>] b, [f32] t) {
  [f32] inv{1.0 - t}
  return(array<f32>(
    a[0] * inv + b[0] * t,
    a[1] * inv + b[1] * t,
    a[2] * inv + b[2] * t
  ))
}

[array<f32>]
reflect([array<f32>] v, [array<f32>] n) {
  [f32] scale{2.0 * dot(v, n)}
  return(sub(v, mul_scalar(n, scale)))
}

[f32]
hit_sphere([array<f32>] center, [f32] radius, [array<f32>] origin, [array<f32>] dir) {
  [array<f32>] oc{sub(origin, center)}
  [f32] a{dot(dir, dir)}
  [f32] b{2.0 * dot(oc, dir)}
  [f32] c{dot(oc, oc) - radius * radius}
  [f32] disc{b * b - 4.0 * a * c}

  if(disc < 0.0) {
    return(-1.0)
  } else {
    return((-b - sqrt(disc)) / (2.0 * a))
  }
}

[array<f32>]
sky_color([array<f32>] dir) {
  [f32] t{0.5 * (dir[1] + 1.0)}
  return(mix(vec(1.0, 1.0, 1.0), vec(0.5, 0.7, 1.0), t))
}

[array<f32>]
shade([array<f32>] base, [array<f32>] normal) {
  [array<f32>] light{normalize(vec(1.0, 1.0, -0.5))}
  [f32] diff{max(0.0, dot(normal, light))}
  [f32] level{0.2 + 0.8 * diff}
  return(mul_scalar(base, level))
}

[array<f32>]
trace([array<f32>] origin, [array<f32>] dir, [int] depth) {
  [array<f32>] c1{vec(0.0, 0.0, -1.0)}
  [array<f32>] c2{vec(1.1, 0.0, -1.6)}
  [f32] r1{0.5}
  [f32] r2{0.5}
  [f32] planeY{-0.6}

  [array<f32> mut] result{vec(0.0, 0.0, 0.0)}
  [array<f32> mut] currentOrigin{origin}
  [array<f32> mut] currentDir{dir}
  [f32 mut] weight{1.0}

  for([int mut] bounce{0}; bounce < depth; ++bounce) {
    [array<f32>] sky{sky_color(currentDir)}
    [f32 mut] closest{1.0e9}
    [int mut] hit{0}

    [f32] t1{hit_sphere(c1, r1, currentOrigin, currentDir)}
    if(t1 > 0.001 && t1 < closest) {
      closest = t1
      hit = 1
    } else {
    }

    [f32] t2{hit_sphere(c2, r2, currentOrigin, currentDir)}
    if(t2 > 0.001 && t2 < closest) {
      closest = t2
      hit = 2
    } else {
    }

    [f32] denom{currentDir[1]}
    if(abs(denom) > 0.0001) {
      [f32] tPlane{(planeY - currentOrigin[1]) / denom}
      if(tPlane > 0.001 && tPlane < closest) {
        closest = tPlane
        hit = 3
      } else {
      }
    } else {
    }

    if(hit == 0) {
      result = add(result, mul_scalar(sky, weight))
      return(result)
    } else {
    }

    [array<f32>] hitPoint{add(currentOrigin, mul_scalar(currentDir, closest))}
    [array<f32> mut] normal{vec(0.0, 1.0, 0.0)}
    [array<f32> mut] base{vec(1.0, 1.0, 1.0)}
    [f32 mut] reflectivity{0.0}

    if(hit == 1) {
      normal = normalize(sub(hitPoint, c1))
      base = vec(0.8, 0.2, 0.2)
      reflectivity = 0.5
    } else {
      if(hit == 2) {
        normal = normalize(sub(hitPoint, c2))
        base = vec(0.2, 0.2, 0.85)
        reflectivity = 0.6
      } else {
        [f32] checker{sin(hitPoint[0] * 4.0) * sin(hitPoint[2] * 4.0)}
        if(checker < 0.0) {
          base = vec(0.1, 0.1, 0.1)
        } else {
          base = vec(0.9, 0.9, 0.9)
        }
        reflectivity = 0.1
      }
    }

    [array<f32>] lit{shade(base, normal)}
    [array<f32>] litScaled{mul_scalar(lit, weight * (1.0 - reflectivity))}
    result = add(result, litScaled)

    weight = weight * reflectivity
    if(weight <= 0.001) {
      return(result)
    } else {
    }

    currentOrigin = add(hitPoint, mul_scalar(normal, 0.001))
    currentDir = normalize(reflect(currentDir, normal))
  }

  result = add(result, mul_scalar(sky_color(currentDir), weight))
  return(result)
}

[int]
to_byte([f32] value) {
  [f32] clamped{clamp(value, 0.0, 1.0)}
  return(convert<int>(clamped * 255.0 + 0.5))
}

[return<Result<FileError>> effects(file_write, io_err)
 on_error<FileError, /log_file_error>("raytracer.ppm"utf8)]
main() {
  [string] path{"raytracer.ppm"utf8}
  [int] width{800}
  [int] height{600}
  [array<f32>] origin{vec(0.0, 0.8, 2.5)}

  [File<Write>] file{File<Write>(path)?}
  file.write_line("P3"utf8)?
  file.write_line(width, " "utf8, height)?
  file.write_line("255"utf8)?

  for([int mut] y{0}; y < height; ++y) {
    for([int mut] x{0}; x < width; ++x) {
      [f32] u{(convert<f32>(x) / convert<f32>(width - 1)) * 2.0 - 1.0}
      [f32] v{(convert<f32>(y) / convert<f32>(height - 1)) * 2.0 - 1.0}
      [array<f32>] dir{normalize(vec(u, -v, -1.5))}
      [array<f32>] color{trace(origin, dir, 2)}
      [int] r{to_byte(color[0])}
      [int] g{to_byte(color[1])}
      [int] b{to_byte(color[2])}

      [on_error<FileError, /log_file_error>("raytracer.ppm"utf8)] block() {
        file.write_line(r, " "utf8, g, " "utf8, b)?
      }
    }
  }

  return(Result.ok())
}

[effects(io_err)]
/log_file_error([FileError] err, [string] path) {
  print_line_error("failed to write: "utf8)
  print_line_error(path)
}
