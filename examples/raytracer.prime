import /math/*

[f32]
hit_sphere([Vec3] center, [f32] radius, [Vec3] origin, [Vec3] dir) {
  [Vec3] oc{origin.sub(center)}
  [f32] a{dir.dot(dir)}
  [f32] b{2.0 * oc.dot(dir)}
  [f32] c{oc.dot(oc) - radius * radius}
  [f32] disc{b * b - 4.0 * a * c}

  if(disc < 0.0) {
    return(-1.0)
  } else {
    [f32] sqrtDisc{sqrt(disc)}
    [f32] invDenom{1.0 / (2.0 * a)}
    [f32] t0{(-b - sqrtDisc) * invDenom}
    [f32] t1{(-b + sqrtDisc) * invDenom}
    if(t0 > 0.0 && t1 > 0.0) {
      if(t0 < t1) {
        return(t0)
      } else {
        return(t1)
      }
    } else {
      if(t1 > 0.0) {
        return(t1)
      } else {
        return(-1.0)
      }
    }
  }
}

[ColorRGB]
sky_color([Vec3] dir) {
  [f32] t{0.5 * (dir.y + 1.0)}
  [ColorRGB] base{ColorRGB(0.2, 0.2, 0.2).mix(ColorRGB(0.5, 0.7, 1.0), t)}
  [ColorRGB] scaled{base.mulScalar(1.5)}
  return(scaled.clamp(0.0, 1.0))
}

[int]
occluded([Vec3] origin, [Vec3] dir, [f32] maxDist) {
  [Vec3] c1{Vec3(0.0, -0.1, -1.0)}
  [Vec3] c2{Vec3(1.1, -0.1, -1.6)}
  [Vec3] c3{Vec3(-1.2, -0.2, -1.4)}
  [f32] r1{0.5}
  [f32] r2{0.5}
  [f32] r3{0.4}
  [f32] planeY{-0.6}

  [f32] t1{hit_sphere(c1, r1, origin, dir)}
  if(t1 > 0.001 && t1 < maxDist) {
    return(1)
  } else {
  }

  [f32] t2{hit_sphere(c2, r2, origin, dir)}
  if(t2 > 0.001 && t2 < maxDist) {
    return(1)
  } else {
  }

  [f32] t3{hit_sphere(c3, r3, origin, dir)}
  if(t3 > 0.001 && t3 < maxDist) {
    return(1)
  } else {
  }

  [f32] denom{dir.y}
  if(abs(denom) > 0.0001) {
    [f32] tPlane{(planeY - origin.y) / denom}
    if(tPlane > 0.001 && tPlane < maxDist) {
      return(1)
    } else {
    }
  } else {
  }

  return(0)
}

[f32]
ambient_occlusion([Vec3] point, [Vec3] normal) {
  [Vec3] up{Vec3(0.0, 1.0, 0.0)}
  [Vec3] fallbackAxis{Vec3(1.0, 0.0, 0.0)}
  [Vec3 mut] tangent{/math/Vec3/cross(up, normal)}
  if(tangent.dot(tangent) <= 0.0001) {
    assign(tangent, /math/Vec3/cross(fallbackAxis, normal))
  } else {
  }
  tangent = tangent.toNormalized()
  [Vec3] bitangent{/math/Vec3/cross(normal, tangent)}

  [Vec3] origin{Vec3(
    point.x + normal.x * 0.001,
    point.y + normal.y * 0.001,
    point.z + normal.z * 0.001
  )}
  [f32] maxDist{2.0}
  [f32 mut] visible{0.0}

  [Vec3] d1{Vec3(
    tangent.x * 0.707 + bitangent.x * 0.0 + normal.x * 0.707,
    tangent.y * 0.707 + bitangent.y * 0.0 + normal.y * 0.707,
    tangent.z * 0.707 + bitangent.z * 0.0 + normal.z * 0.707
  ).toNormalized()}
  [Vec3] d2{Vec3(
    tangent.x * -0.707 + bitangent.x * 0.0 + normal.x * 0.707,
    tangent.y * -0.707 + bitangent.y * 0.0 + normal.y * 0.707,
    tangent.z * -0.707 + bitangent.z * 0.0 + normal.z * 0.707
  ).toNormalized()}
  [Vec3] d3{Vec3(
    tangent.x * 0.0 + bitangent.x * 0.707 + normal.x * 0.707,
    tangent.y * 0.0 + bitangent.y * 0.707 + normal.y * 0.707,
    tangent.z * 0.0 + bitangent.z * 0.707 + normal.z * 0.707
  ).toNormalized()}
  [Vec3] d4{Vec3(
    tangent.x * 0.0 + bitangent.x * -0.707 + normal.x * 0.707,
    tangent.y * 0.0 + bitangent.y * -0.707 + normal.y * 0.707,
    tangent.z * 0.0 + bitangent.z * -0.707 + normal.z * 0.707
  ).toNormalized()}

  if(occluded(origin, d1, maxDist) == 0) { visible = visible + 1.0 } else {}
  if(occluded(origin, d2, maxDist) == 0) { visible = visible + 1.0 } else {}
  if(occluded(origin, d3, maxDist) == 0) { visible = visible + 1.0 } else {}
  if(occluded(origin, d4, maxDist) == 0) { visible = visible + 1.0 } else {}

  return(visible / 4.0)
}

[ColorRGB]
shade([ColorRGB] base, [Vec3] normal, [Vec3] point) {
  [Vec3] light{Vec3(1.0, 1.0, -0.5).toNormalized()}
  [f32] diff{max(0.0, normal.dot(light))}
  [f32] level{0.2 + 0.8 * diff}
  [f32] ao{ambient_occlusion(point, normal)}
  return(base.mulScalar(level * ao))
}

[ColorRGB]
trace_direct([Vec3] origin, [Vec3] dir) {
  [Vec3] c1{Vec3(0.0, -0.1, -1.0)}
  [Vec3] c2{Vec3(1.1, -0.1, -1.6)}
  [Vec3] c3{Vec3(-1.2, -0.2, -1.4)}
  [f32] r1{0.5}
  [f32] r2{0.5}
  [f32] r3{0.4}
  [f32] planeY{-0.6}

  [f32 mut] closest{1.0e9}
  [int mut] hit{0}

  [f32] t1{hit_sphere(c1, r1, origin, dir)}
  if(t1 > 0.001 && t1 < closest) {
    closest = t1
    hit = 1
  } else {
  }

  [f32] t2{hit_sphere(c2, r2, origin, dir)}
  if(t2 > 0.001 && t2 < closest) {
    closest = t2
    hit = 2
  } else {
  }

  [f32] t3{hit_sphere(c3, r3, origin, dir)}
  if(t3 > 0.001 && t3 < closest) {
    closest = t3
    hit = 4
  } else {
  }

  [f32] denom{dir.y}
  if(abs(denom) > 0.0001) {
    [f32] tPlane{(planeY - origin.y) / denom}
    if(tPlane > 0.001 && tPlane < closest) {
      closest = tPlane
      hit = 3
    } else {
    }
  } else {
  }

  if(hit == 0) {
    return(sky_color(dir))
  } else {
  }

  [Vec3] hitStep{dir.mulScalar(closest)}
  [Vec3] hitPoint{origin.add(hitStep)}
  [Vec3 mut] normal{Vec3(0.0, 1.0, 0.0)}
  [ColorRGB mut] base{ColorRGB(1.0, 1.0, 1.0)}

  if(hit == 1) {
    [Vec3] normalRaw{hitPoint.sub(c1)}
    normal = normalRaw.toNormalized()
    base = ColorRGB(0.8, 0.2, 0.2)
  } else {
    if(hit == 2) {
      [Vec3] normalRaw{hitPoint.sub(c2)}
      normal = normalRaw.toNormalized()
      base = ColorRGB(0.2, 0.2, 0.85)
    } else {
      if(hit == 4) {
        [Vec3] normalRaw{hitPoint.sub(c3)}
        normal = normalRaw.toNormalized()
        base = ColorRGB(1.0, 1.0, 1.0)
      } else {
        [f32] checker{sin(hitPoint.x * 4.0) * sin(hitPoint.z * 4.0)}
        if(checker < 0.0) {
          base = ColorRGB(0.1, 0.1, 0.1)
        } else {
          base = ColorRGB(0.9, 0.9, 0.9)
        }
      }
    }
  }

  return(shade(base, normal, hitPoint))
}

[ColorRGB]
trace_direct_skip_glass([Vec3] origin, [Vec3] dir) {
  [Vec3] c1{Vec3(0.0, -0.1, -1.0)}
  [Vec3] c2{Vec3(1.1, -0.1, -1.6)}
  [Vec3] c3{Vec3(-1.2, -0.2, -1.4)}
  [f32] r1{0.5}
  [f32] r2{0.5}
  [f32] r3{0.4}
  [f32] planeY{-0.6}

  [f32 mut] closest{1.0e9}
  [int mut] hit{0}

  [f32] t1{hit_sphere(c1, r1, origin, dir)}
  if(t1 > 0.001 && t1 < closest) {
    closest = t1
    hit = 1
  } else {
  }

  [f32] t2{hit_sphere(c2, r2, origin, dir)}
  if(t2 > 0.001 && t2 < closest) {
    closest = t2
    hit = 2
  } else {
  }

  [f32] denom{dir.y}
  if(abs(denom) > 0.0001) {
    [f32] tPlane{(planeY - origin.y) / denom}
    if(tPlane > 0.001 && tPlane < closest) {
      closest = tPlane
      hit = 3
    } else {
    }
  } else {
  }

  if(hit == 0) {
    return(sky_color(dir))
  } else {
  }

  [Vec3] hitStep{dir.mulScalar(closest)}
  [Vec3] hitPoint{origin.add(hitStep)}
  [Vec3 mut] normal{Vec3(0.0, 1.0, 0.0)}
  [ColorRGB mut] base{ColorRGB(1.0, 1.0, 1.0)}

  if(hit == 1) {
    [Vec3] normalRaw{hitPoint.sub(c1)}
    normal = normalRaw.toNormalized()
    base = ColorRGB(0.8, 0.2, 0.2)
  } else {
    if(hit == 2) {
      [Vec3] normalRaw{hitPoint.sub(c2)}
      normal = normalRaw.toNormalized()
      base = ColorRGB(0.2, 0.2, 0.85)
    } else {
      if(hit == 3) {
        [f32] checker{sin(hitPoint.x * 4.0) * sin(hitPoint.z * 4.0)}
        if(checker < 0.0) {
          base = ColorRGB(0.1, 0.1, 0.1)
        } else {
          base = ColorRGB(0.9, 0.9, 0.9)
        }
      } else {
      }
    }
  }

  return(shade(base, normal, hitPoint))
}

[ColorRGB]
trace([Vec3] origin, [Vec3] dir, [int] depth) {
  [Vec3] c1{Vec3(0.0, -0.1, -1.0)}
  [Vec3] c2{Vec3(1.1, -0.1, -1.6)}
  [Vec3] c3{Vec3(-1.2, -0.2, -1.4)}
  [f32] r1{0.5}
  [f32] r2{0.5}
  [f32] r3{0.4}
  [f32] planeY{-0.6}

  [ColorRGB mut] result{ColorRGB(0.0, 0.0, 0.0)}
  [Vec3 mut] currentOrigin{origin}
  [Vec3 mut] currentDir{dir}
  [f32 mut] weight{1.0}
  [ColorRGB mut] filter{ColorRGB(1.0, 1.0, 1.0)}

  for([int mut] bounce{0}; bounce < depth; ++bounce) {
    [ColorRGB] sky{sky_color(currentDir)}
    [f32 mut] closest{1.0e9}
    [int mut] hit{0}

    [f32] t1{hit_sphere(c1, r1, currentOrigin, currentDir)}
    if(t1 > 0.001 && t1 < closest) {
      closest = t1
      hit = 1
    } else {
    }

    [f32] t2{hit_sphere(c2, r2, currentOrigin, currentDir)}
    if(t2 > 0.001 && t2 < closest) {
      closest = t2
      hit = 2
    } else {
    }

    [f32] t3{hit_sphere(c3, r3, currentOrigin, currentDir)}
    if(t3 > 0.001 && t3 < closest) {
      closest = t3
      hit = 4
    } else {
    }

    [f32] denom{currentDir.y}
    if(abs(denom) > 0.0001) {
      [f32] tPlane{(planeY - currentOrigin.y) / denom}
      if(tPlane > 0.001 && tPlane < closest) {
        closest = tPlane
        hit = 3
      } else {
      }
    } else {
    }

    if(hit == 0) {
      [ColorRGB] skyScaled{sky.mulScalar(weight)}
      [ColorRGB] skyFiltered{skyScaled.mul(filter)}
      result = result.add(skyFiltered)
      return(result)
    } else {
    }

    [Vec3] hitStep{currentDir.mulScalar(closest)}
    [Vec3] hitPoint{currentOrigin.add(hitStep)}
    [Vec3 mut] normal{Vec3(0.0, 1.0, 0.0)}
    [ColorRGB mut] base{ColorRGB(1.0, 1.0, 1.0)}
    [f32 mut] reflectivity{0.0}
    [int mut] isGlass{0}

    if(hit == 1) {
      [Vec3] normalRaw{hitPoint.sub(c1)}
      normal = normalRaw.toNormalized()
      base = ColorRGB(0.8, 0.2, 0.2)
      reflectivity = 0.75
    } else {
      if(hit == 2) {
        [Vec3] normalRaw{hitPoint.sub(c2)}
        normal = normalRaw.toNormalized()
        base = ColorRGB(0.2, 0.2, 0.85)
        reflectivity = 0.85
      } else {
        if(hit == 4) {
          [Vec3] normalRaw{hitPoint.sub(c3)}
          normal = normalRaw.toNormalized()
          base = ColorRGB(1.0, 1.0, 1.0)
          reflectivity = 0.0
          isGlass = 1
        } else {
          [f32] checker{sin(hitPoint.x * 4.0) * sin(hitPoint.z * 4.0)}
          if(checker < 0.0) {
            base = ColorRGB(0.1, 0.1, 0.1)
          } else {
            base = ColorRGB(0.9, 0.9, 0.9)
          }
          reflectivity = 0.1
        }
      }
    }

    if(isGlass == 1) {
      [f32] ior{1.5}
      [f32] cosTheta{clamp(abs(currentDir.dot(normal)), 0.0, 1.0)}
      [f32 mut] r0{(1.0 - ior) / (1.0 + ior)}
      r0 = r0 * r0
      [f32] fresnelBase{1.0 - cosTheta}
      [f32] fresnelSq{fresnelBase * fresnelBase}
      [f32] fresnelFourth{fresnelSq * fresnelSq}
      [f32] fresnelPow{fresnelFourth * fresnelBase}
      [f32 mut] fresnel{r0 + (1.0 - r0) * fresnelPow}
      fresnel = min(1.0, 0.3 + fresnel * 3.0)

      [f32 mut] cosi{clamp(currentDir.dot(normal), -1.0, 1.0)}
      [f32 mut] etai{1.0}
      [f32 mut] etat{ior}
      if(cosi > 0.0) {
        [f32] tmp{etai}
        etai = etat
        etat = tmp
      } else {
        cosi = -cosi
      }
      [f32] eta{etai / etat}
      [f32] k{1.0 - eta * eta * (1.0 - cosi * cosi)}
      if(k < 0.0) {
        fresnel = 1.0
      } else {
      }

      [f32] ndot{currentDir.dot(normal)}
      [int mut] frontFace{0}
      if(ndot < 0.0) {
        frontFace = 1
      } else {
      }

      [Vec3] reflectVec{currentDir.reflect(normal)}
      [Vec3] reflectDir{reflectVec.toNormalized()}
      [Vec3 mut] reflectOffset{normal.mulScalar(0.001)}
      if(frontFace == 0) {
        reflectOffset = normal.mulScalar(-0.001)
      } else {
      }
      [Vec3] reflOrigin{hitPoint.add(reflectOffset)}

      [Vec3] refrVec{currentDir.refract(normal, ior)}
      [Vec3] refrDir{refrVec.toNormalized()}
      [Vec3 mut] refractOffset{normal.mulScalar(-0.001)}
      if(frontFace == 0) {
        refractOffset = normal.mulScalar(0.001)
      } else {
      }
      [Vec3] refrOrigin{hitPoint.add(refractOffset)}

      [ColorRGB] reflColor{trace_direct_skip_glass(reflOrigin, reflectDir)}
      [ColorRGB mut] refrColor{ColorRGB(0.0, 0.0, 0.0)}
      if(fresnel < 1.0) {
        refrColor = trace_direct_skip_glass(refrOrigin, refrDir)
      } else {
      }

      [ColorRGB] reflScaled{reflColor.mulScalar(weight * fresnel)}
      [ColorRGB] reflFiltered{reflScaled.mul(filter)}

      [ColorRGB] refrScaled{refrColor.mulScalar(weight * (1.0 - fresnel))}
      [ColorRGB] refrFilteredBase{refrScaled.mul(filter)}
      [ColorRGB] refrFiltered{refrFilteredBase.mul(base)}

      [ColorRGB] reflSum{reflFiltered.add(refrFiltered)}
      result = result.add(reflSum)
      return(result)
    } else {
      [ColorRGB] lit{shade(base, normal, hitPoint)}
      [ColorRGB] litScaled{lit.mulScalar(weight * (1.0 - reflectivity))}
      [ColorRGB] litFiltered{litScaled.mul(filter)}
      result = result.add(litFiltered)

      weight = weight * reflectivity
      if(weight <= 0.001) {
        return(result)
      } else {
      }

      [Vec3] reflectOffset{normal.mulScalar(0.001)}
      currentOrigin = hitPoint.add(reflectOffset)
      [Vec3] reflectStep{currentDir.reflect(normal)}
      currentDir = reflectStep.toNormalized()
    }
  }

  [ColorRGB] tailSkyBase{sky_color(currentDir)}
  [ColorRGB] tailSky{tailSkyBase.mulScalar(weight)}
  [ColorRGB] tailFiltered{tailSky.mul(filter)}
  result = result.add(tailFiltered)
  return(result)
}

[int]
to_byte([f32] value) {
  [f32] clamped{clamp(value, 0.0, 1.0)}
  return(convert<int>(clamped * 255.0 + 0.5))
}

[return<int> effects(io_out)]
main() {
  [int] width{1028}
  [int] height{1028}
  [int] samples{2}
  [f32] sampleScale{1.0 / (convert<f32>(samples) * convert<f32>(samples))}
  [Vec3] origin{Vec3(0.0, 0.8, 2.5)}

  print_line("P3"utf8)
  print(width)
  print(" "utf8)
  print_line(height)
  print_line("255"utf8)

  for([int mut] y{0}; y < height; ++y) {
    for([int mut] x{0}; x < width; ++x) {
      [ColorRGB mut] accum{ColorRGB(0.0, 0.0, 0.0)}
      for([int mut] sy{0}; sy < samples; ++sy) {
        for([int mut] sx{0}; sx < samples; ++sx) {
          [f32] jitterX{(convert<f32>(sx) + 0.5) / convert<f32>(samples)}
          [f32] jitterY{(convert<f32>(sy) + 0.5) / convert<f32>(samples)}
          [f32] u{((convert<f32>(x) + jitterX) / convert<f32>(width - 1)) * 2.0 - 1.0}
          [f32] v{((convert<f32>(y) + jitterY) / convert<f32>(height - 1)) * 2.0 - 1.0}
          [Vec3] dir{Vec3(u, -v, -1.5).toNormalized()}
          [ColorRGB] sample{trace(origin, dir, 4)}
          accum = accum.add(sample)
        }
      }
      [ColorRGB] color{accum.mulScalar(sampleScale)}
      [int] r{to_byte(color.r)}
      [int] g{to_byte(color.g)}
      [int] b{to_byte(color.b)}

      print(r)
      print(" "utf8)
      print(g)
      print(" "utf8)
      print_line(b)
    }
  }

  return(0i32)
}
